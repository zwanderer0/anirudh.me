<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Wave Alchemy — System Simulation</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
  canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H, dpr;

  function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  // ─── System parameters ───
  const NUM_PINS = 48;

  // ─── Simulated energy input signal ───
  // Models captured environmental energy: audio amplitude envelope
  // mixed with kinetic/motion data (accelerometer-like)
  function inputSignal(x, t) {
    // Audio component — harmonic content
    const audio = Math.sin(x * 8.0 - t * 2.0) * 0.5
                + Math.sin(x * 13.0 + t * 1.3) * 0.25
                + Math.sin(x * 21.0 - t * 3.5) * 0.12;
    // Kinetic/motion component — slower, broader
    const motion = Math.sin(x * 3.0 + t * 0.4) * 0.35
                 + Math.sin(x * 1.2 - t * 0.15) * 0.2;
    // Combined energy
    return audio * 0.55 + motion * 0.45;
  }

  // ─── Motor model ───
  // Each pin has a motor with inertia — doesn't jump instantly
  // to target. Models real servo/stepper response.
  const motorPositions = new Float64Array(NUM_PINS);  // current
  const motorTargets   = new Float64Array(NUM_PINS);  // target from signal
  const motorVelocity  = new Float64Array(NUM_PINS);
  const MOTOR_STIFFNESS = 8.0;   // spring constant
  const MOTOR_DAMPING   = 3.5;   // damping ratio

  function updateMotors(dt) {
    for (let i = 0; i < NUM_PINS; i++) {
      const err = motorTargets[i] - motorPositions[i];
      const force = err * MOTOR_STIFFNESS - motorVelocity[i] * MOTOR_DAMPING;
      motorVelocity[i] += force * dt;
      motorPositions[i] += motorVelocity[i] * dt;
    }
  }

  // ─── Drawing helpers ───
  function label(text, x, y, alpha) {
    ctx.font = '10px monospace';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha || 0.35})`;
    ctx.fillText(text, x, y);
  }

  function labelRight(text, x, y, alpha) {
    ctx.font = '10px monospace';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha || 0.35})`;
    ctx.textAlign = 'right';
    ctx.fillText(text, x, y);
    ctx.textAlign = 'left';
  }

  function hline(y, x1, x2, alpha) {
    ctx.beginPath();
    ctx.moveTo(x1, y);
    ctx.lineTo(x2, y);
    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha || 0.08})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  function dashedHline(y, x1, x2, alpha) {
    ctx.beginPath();
    ctx.setLineDash([3, 4]);
    ctx.moveTo(x1, y);
    ctx.lineTo(x2, y);
    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha || 0.06})`;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // ─── Draw continuous input signal waveform ───
  function drawInputSignal(t, left, right, centerY, ampH) {
    ctx.beginPath();
    for (let px = left; px <= right; px++) {
      const x = (px - left) / (right - left);
      const val = inputSignal(x, t);
      const py = centerY - val * ampH;
      if (px === left) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 1.2;
    ctx.stroke();
  }

  // ─── Draw sampled signal (discrete samples at pin positions) ───
  function drawSampledSignal(t, left, right, centerY, ampH) {
    const pinW = (right - left) / NUM_PINS;
    for (let i = 0; i < NUM_PINS; i++) {
      const x = (i + 0.5) / NUM_PINS;
      const val = inputSignal(x, t);
      const px = left + (i + 0.5) * pinW;
      const py = centerY - val * ampH;

      // Vertical sample line
      ctx.beginPath();
      ctx.moveTo(px, centerY);
      ctx.lineTo(px, py);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Sample dot
      ctx.beginPath();
      ctx.arc(px, py, 2, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fill();
    }
  }

  // ─── Draw motor target vs actual (shows motor lag) ───
  function drawMotorState(left, right, centerY, ampH) {
    const pinW = (right - left) / NUM_PINS;
    for (let i = 0; i < NUM_PINS; i++) {
      const px = left + (i + 0.5) * pinW;
      const targetY = centerY - motorTargets[i] * ampH;
      const actualY = centerY - motorPositions[i] * ampH;

      // Target (faint)
      ctx.beginPath();
      ctx.arc(px, targetY, 1.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fill();

      // Actual motor position (brighter)
      ctx.beginPath();
      ctx.moveTo(px, centerY);
      ctx.lineTo(px, actualY);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(px, actualY, 2, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fill();
    }
  }

  // ─── Draw physical pin array (the Radical Atoms output) ───
  function drawPinArray(left, right, baseY, maxH) {
    const pinW = (right - left) / NUM_PINS;
    const rodW = Math.max(2, pinW * 0.35);
    const tipR = Math.max(3, pinW * 0.3);

    for (let i = 0; i < NUM_PINS; i++) {
      const px = left + (i + 0.5) * pinW;
      const displacement = motorPositions[i];
      const h = displacement * maxH;
      const tipY = baseY - h;

      // Rod (physical pin shaft)
      ctx.beginPath();
      ctx.moveTo(px, baseY);
      ctx.lineTo(px, tipY);
      ctx.strokeStyle = 'rgba(180, 180, 180, 0.5)';
      ctx.lineWidth = rodW;
      ctx.lineCap = 'butt';
      ctx.stroke();

      // Spherical tip
      const bright = 0.4 + 0.6 * Math.abs(displacement);
      ctx.beginPath();
      ctx.arc(px, tipY, tipR, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${bright})`;
      ctx.fill();

      // Housing slot (base)
      ctx.beginPath();
      ctx.rect(px - rodW * 0.8, baseY, rodW * 1.6, 4);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.fill();
    }

    // Base housing bar
    ctx.beginPath();
    ctx.rect(left - 4, baseY, right - left + 8, 6);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // ─── Draw flow arrows between stages ───
  function drawArrow(x, y1, y2, text) {
    const midY = (y1 + y2) / 2;

    ctx.beginPath();
    ctx.moveTo(x, y1 + 8);
    ctx.lineTo(x, y2 - 8);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Arrowhead
    ctx.beginPath();
    ctx.moveTo(x, y2 - 8);
    ctx.lineTo(x - 3, y2 - 14);
    ctx.lineTo(x + 3, y2 - 14);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
    ctx.fill();

    if (text) {
      ctx.font = '9px monospace';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.18)';
      ctx.fillText(text, x + 8, midY + 3);
    }
  }

  // ─── Main loop ───
  let prevTimestamp = null;

  function frame(timestamp) {
    if (!prevTimestamp) prevTimestamp = timestamp;
    const dt = Math.min((timestamp - prevTimestamp) / 1000, 0.05);
    prevTimestamp = timestamp;
    const t = timestamp / 1000;

    // Layout
    const margin = 60;
    const left = margin + 30;
    const right = W - margin;
    const totalH = H - margin * 2;

    // 4 stages vertically
    const stage1Y = margin + totalH * 0.08;   // Input signal
    const stage2Y = margin + totalH * 0.30;   // Sampled / discretized
    const stage3Y = margin + totalH * 0.52;   // Motor response
    const stage4base = margin + totalH * 0.92; // Pin array base
    const ampH = totalH * 0.08;
    const pinMaxH = totalH * 0.22;

    // Update motor targets from input signal
    for (let i = 0; i < NUM_PINS; i++) {
      const x = (i + 0.5) / NUM_PINS;
      motorTargets[i] = inputSignal(x, t);
    }
    updateMotors(dt);

    // ─── Clear ───
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    // ─── Stage 1: Continuous input energy ───
    label('INPUT ENERGY', left, stage1Y - ampH - 12, 0.4);
    labelRight('continuous signal: audio + kinetic', right, stage1Y - ampH - 12, 0.2);
    hline(stage1Y, left, right, 0.06);
    drawInputSignal(t, left, right, stage1Y, ampH);

    // ─── Arrow: sampling ───
    drawArrow(left - 16, stage1Y + ampH + 4, stage2Y - ampH - 4, 'sample');

    // ─── Stage 2: Discretized (sampled at pin positions) ───
    label('SAMPLED', left, stage2Y - ampH - 12, 0.4);
    labelRight('n=' + NUM_PINS + ' discrete positions', right, stage2Y - ampH - 12, 0.2);
    hline(stage2Y, left, right, 0.06);
    drawSampledSignal(t, left, right, stage2Y, ampH);

    // ─── Arrow: motor drive ───
    drawArrow(left - 16, stage2Y + ampH + 4, stage3Y - ampH - 4, 'motor drive');

    // ─── Stage 3: Motor response (target vs actual) ───
    label('MOTOR ARRAY', left, stage3Y - ampH - 12, 0.4);
    labelRight('spring-damper: k=' + MOTOR_STIFFNESS + ' c=' + MOTOR_DAMPING, right, stage3Y - ampH - 12, 0.2);
    hline(stage3Y, left, right, 0.06);
    dashedHline(stage3Y - ampH, left, right, 0.04);
    dashedHline(stage3Y + ampH, left, right, 0.04);
    drawMotorState(left, right, stage3Y, ampH);

    // ─── Arrow: physical actuation ───
    drawArrow(left - 16, stage3Y + ampH + 4, stage4base - pinMaxH - 14, 'actuate');

    // ─── Stage 4: Physical pin array (Radical Atoms) ───
    label('RADICAL ATOMS OUTPUT', left, stage4base - pinMaxH - 20, 0.4);
    labelRight('pin-actuated waveform sculpture', right, stage4base - pinMaxH - 20, 0.2);
    drawPinArray(left, right, stage4base, pinMaxH);

    // ─── System title ───
    ctx.font = '11px monospace';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
    ctx.fillText('WAVE ALCHEMY — energy transduction pipeline', left, margin - 16);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
